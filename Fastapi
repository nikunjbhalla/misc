# services/users_service.py

class UsersService:
    def get_user(self, user_id: int):
        # Service logic to fetch user by ID
        return {"id": user_id, "name": "John Doe"}


# services/products_service.py

class ProductsService:
    def get_product(self, product_id: int):
        # Service logic to fetch product by ID
        return {"id": product_id, "name": "Sample Product"}


# controllers/users_controller.py

from fastapi import APIRouter, Depends

from services.users_service import UsersService

router = APIRouter()


@router.get("/users/{user_id}")
def get_user_handler(user_id: int, users_service: UsersService = Depends()):
    user = users_service.get_user(user_id)
    return user



# controllers/products_controller.py

from fastapi import APIRouter, Depends

from services.products_service import ProductsService

router = APIRouter()


@router.get("/products/{product_id}")
def get_product_handler(product_id: int, products_service: ProductsService = Depends()):
    product = products_service.get_product(product_id)
    return product


# main.py

from fastapi import FastAPI

from controllers.users_controller import router as users_router
from controllers.products_controller import router as products_router
from services.users_service import UsersService
from services.products_service import ProductsService

app = FastAPI()

app.include_router(users_router, prefix="/api/users", tags=["users"])
app.include_router(products_router, prefix="/api/products", tags=["products"])


@app.on_event("startup")
async def startup():
    # Dependency Injection setup
    app.users_service = UsersService()
    app.products_service = ProductsService()
    

@app.on_event("shutdown")
async def shutdown():
    # Clean up resources if needed
    pass



# main.py

from fastapi import FastAPI
from fastapi.openapi.utils import get_openapi
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

from controllers.users_controller import router as users_router
from controllers.products_controller import router as products_router
from services.users_service import UsersService
from services.products_service import ProductsService

app = FastAPI()

app.include_router(users_router, prefix="/api/users", tags=["users"])
app.include_router(products_router, prefix="/api/products", tags=["products"])


@app.on_event("startup")
async def startup():
    # Dependency Injection setup
    app.users_service = UsersService()
    app.products_service = ProductsService()


@app.on_event("shutdown")
async def shutdown():
    # Clean up resources if needed
    pass


# Custom Exception Handler
@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request, exc):
    return JSONResponse(
        status_code=400,
        content={"detail": "Invalid request parameters"},
    )


# Generate OpenAPI JSON Schema with Customized Information
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    openapi_schema = get_openapi(
        title="Your API Name",
        version="1.0.0",
        description="Your API Description",
        routes=app.routes,
    )
    app.openapi_schema = openapi_schema
    return app.openapi_schema


app.openapi = custom_openapi




from cryptography import x509
from cryptography.hazmat.primitives import serialization

# Load the certificate
with open('path_to_certificate.pem', 'rb') as cert_file:
    cert_data = cert_file.read()
    cert = x509.load_pem_x509_certificate(cert_data)

# Load the private key
with open('path_to_private_key.pem', 'rb') as key_file:
    key_data = key_file.read()
    private_key = serialization.load_pem_private_key(key_data, password=None)



import datetime
import jwt

# Define the JWT token payload
payload = {
    'iss': 'issuer',
    'sub': 'subject',
    'exp': datetime.datetime.utcnow() + datetime.timedelta(minutes=15),
    # Add any additional claims as needed
}

# Sign the payload with the private key
token = jwt.encode(payload, private_key, algorithm='RS256')




